# message2

An experimental reference implementation of the MessageFormat 2 standard in TypeScript.

## Goals

* Follow the spec development and provide an additional implementation.
* Validate the ideas discussed in MFWG through an implementation.
* Demonstrate one concrete parsing and runtime model to help these discussions.

## Design Principles

* Strict conformance to the spec.
* All formatting and matching functions implemented as custom functions in userspace.
* No `any` or `unknown`; use interfaces and generics instead.
* No shortcuts nor special cases in the code.

## Overview

The codebase is organized in the following directories:

* `syntax` — the parser and the definition of the AST data model.
* `runtime` — the `MessageFormat` class which parses and formats messages.
* `registry` — implementations of formatting and matching functions.
* `command` — CLI tools which can be used for testing and inspecting the behavior of the implementation.
* `example` — examples of messages and custom functions; they also double as tests.

Remember to compile TypeScript to JavaScript before you run the examples and CLI tools.

    $ npm install
	$ npx tsc

## Parsing

Parsing is divided into three steps:

* *scanning* for "atoms" based on whitespace and word boundary characters, such as `{`, `}`, `=`, etc.,
* *lexing* which consists of categorizing the atoms into tokens based on their values and the analyzed position in the source,
* and finally *parsing* which builds the AST from the stream of tokens.

Due to MessageFormat's use of curly braces as delimiters for both text and expressions, the lexing step requires an almost complete analysis of the source according to the formal grammar. Consider the process of deciding whether an atom is part of a text production or part of an expression:

![message](diagram/message.svg)
![Railroad-Diagram-Generator](diagram/Railroad-Diagram-Generator.svg) <sup>generated by [RR - Railroad Diagram Generator](https://bottlecaps.de/rr/ui)</sup>

Since the lexical analysis is already quite advanced, I decided to perform a complete verification of well-formedness in the lexer. The lexer checks whether option names are valid `name` productions, whether option names are followed by an equals sign, whether option values are valid nmtokens, variable names, or literals, whether the variant keys are separated by whitespace, etc. This leaves little work for the parser, which in fact is mostly concerned about building a tree out of the stream of tokens. Most grammar-related errors are caught during the lexical analysis.

While the lexer generates a flat stream of categorized tokens, the parser produces an AST, defined in [`syntax/ast.ts`](syntax/ast.ts). The AST is then used by the runtime to format translations.

## Runtime

The runtime exposes the `MessageFormat` class. The goal of that class is to:

* take a string with the contents of a single message,
* parse it to an AST,
* format it to either a string or an iterator of parts
* using interpolated data provided at the callsite (i.e. the "message arguments").

It is intended as a prototype of the future [`Intl.MessageFormat` API](https://github.com/tc39/proposal-intl-messageformat).

```js
let message = new MessageFormat("en-US", "{Hello, {$userName}!}");

// Format the message to a string.
let value = message.format({userName: new RuntimeString("Alice")}),
assert.equal(value, "Hello, Alice!");

// Format the message to an iterator of parts.
let iter = message.formatToParts({userName: new RuntimeString("Bob")});
assert.deepEqual(iter.next().value, {type: "literal", value: "Hello, "});
assert.deepEqual(iter.next().value, {type: "literal", value: "Bob"});
assert.deepEqual(iter.next().value, {type: "literal", value: "!"});
assert.equal(iter.next().done, true);
```

I'm still working on the implementation of `MessageFormat`. Currently, the following parts are missing or require more discussion:

- [ ] Support local declarations.
- [ ] Handle errors according to the [spec draft](https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#error-handling).
- [ ] (Maybe) allow passing native JavaScript types, such as `string`, `number`, and `Date` as message arguments. 
- [ ] Decide on the shape and types of parts yielded by `formatToParts`.
- [ ] Establish a model for error handling of registry functions.

## Registry

The registry contains implementations of formatting and matching functions. All functions available in `message2` are registered functions, even `:number` and `:plural`. The goal is to ensure that registered functions can be as powerful and expressive as necessary. Some modules in the registry also provide custom runtime types. For instance, [`registry/number.ts`](registry/number.ts) provides `RuntimeNumber` which formats numbers and matches them by value, and `PluralMatcher` which matches numbers by value and by LDML plural category.

The only type built into the runtime rather than the registry is the [`RuntimeString`](runtime/RuntimeString.js), which is the runtime representation of `ast.Literal`.

## Commands

* `node command/lex.mjs` to print a list of tokens recognized by the lexer.
* `node command/parse.mjs` to print a JSON representation of the AST parsed by the parser.

Both tools take `stdin` as input, or can be passed a path to a text file containing a single message. When trying out things, it's convenient to take advantage of process substitution, available in bash and zsh:

    $ node parse.mjs <(echo "{Hello, world!}")

## Examples

Run each example individually by passing its name to `node example/index.js`:

    $ node example/index.js string
    $ node example/index.js number
    $ node example/index.js plural
    $ node example/index.js opaque

Alterantively, run all examples at once:

	$ npm test
